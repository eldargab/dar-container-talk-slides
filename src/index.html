<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" type="text/css" href="../node_modules/reveal.js/css/reveal.css">
  <link rel="stylesheet" type="text/css" href="./index.styl">
  <link rel="stylesheet" type="text/css" href="../node_modules/highlight.js/styles/vs.css">
  <title>Dependency Injection: Расширяем область применения</title>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <section id="title">
        <h1 class="f3 fw-300 gray mb2">Dependency Injection</h1>
        <p class="">Расширяем область применения</p>
      </section>

      <section id="goals">
        <h1 class="f3 fw-300 gray mb3 ">Цели доклада</h1>
        <ol>
          <li class="mb2 fragment">Сформулировать ключевую идею лежащую в основе DI</li>
          <li class="mb2 fragment">Представить новый контейнер</li>
        </ol>
        <aside class="notes">
          В этом докладе мы хотим представить новый контейнер.
          Он весьма не похож на традиционные Java контейнеры
          и обладает важной особенностью, которая позволяет применять
          ключевую идею, лежащую в основе DI, более широко и с большим успехом.
          <br><br>
          С формулировки ключевой идеи DI (а так же такой системы сборки как Make)
          мы и начнём...
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre><code class="javascript"><include src="./examples/abc.js"/></code></pre>
          <img src="./examples/abc.svg" class="ml5" style="height: 70%; opacity: 0.7;">
        </div>
        <aside class="notes">
          Для этого посмотрим на наш код не как на некую последовательность действий,
          а как на граф, вершины которого обозначают элементарные операции,
          а рёбра их непосредственную зависимость от результатов других операций.
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre class="fragment"><code class="javascript"><include src="./examples/simple.js"/></code></pre>
          <img src="./examples/simple.svg" class="ml4" style="height: 70%; opacity: 0.7;">
        </div>
        <aside class="notes">
          В самом оптимистичном случае такой граф будет представлять собой дерево.
          Дерево замечательно тем, что для его реализации нам достаточно самых базовых
          приёмов программирования. Действительно, если операций станет слишком много,
          мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
          оставаться простой.
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre><code class="javascript"><include src="./examples/complex.js"/></code></pre>
          <img src="./examples/complex.svg" class="ml6 fragment" style="height: 80%; opacity: 0.7;">
        </div>
        <aside class="notes">
          Посмортим, что будет в пессимичном случае...
          <br><br>
          Для этого рассмотрим следующий псевдокод (let result = ...).
          С математической точки зрения, алгоритм полностью определён, состоит из простых элементов,
          но кто в течении нескольких секунд сможет с лёгкостью определить их правильный порядок?
          А если таких выражений будет 100 или 1000?
          <br><br>
          Что интересно, единственно как мы можем запрограммировать такой граф, это
          кропотливо записать элементарные операции в едином монолитном куске кода.
          Действительно, любая попытка разбить его на отдельные подпрограммы
          приведёт только к усложнению (ведь кол-во входных/выходных параметров будет не меньшим чем кол-во объединённых операций),
          а небольшие изменения в спецификации скорее всего разрушат всю концепцию отдельно взятого разбиения.
          <br><br>
          Естественно, мы можем не программировать всё это вручную.
          Приведём пример того, как это может выглядеть.
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
<pre>
<code class="javascript"><include src="./examples/container-1.js"/></code>
<code class="javascript fragment"><include src="./examples/container-2.js"/></code>
</pre>
          <img src="./examples/complex.svg" class="ml6" style="height: 80%; opacity: 0.7;">
        </div>
      </section>

      <section style="margin-top: -2%">
        <pre><code class="javascript"><span class="fragment">app.def('response', (user) => `Hello ${user}!`)</span>

<span class="fragment">app.def('user', (db, cookies) => db.getUser(cookies.user)))</span>

<span class="fragment">app.def('cookies', (req) => parse(req.headers['Cookie'])))</span>

<span class="fragment">app.def('db', () => open('mysql://...'))</span><span class="fragment"> // При каждом запросе ???</span>

<span class="fragment">app.level('Response', 'response', ['req']) // Уровень !!!</span>

<span class="fragment">app.def('main', function(Response) {
  http.createServer(function(req, res)) {
    let msg = Response(req)
    res.setHeader('Content-Type', 'text/plain');
    res.end(msg);
  })
})</span>

<span class="fragment">app.compile('main')(); // Запускаем</span></code></pre>
      </section>

    </div>
  </div>
  <script type="text/javascript" src="./index.js"></script>
</body>
</html>