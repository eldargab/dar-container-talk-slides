<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" type="text/css" href="../reveal/reveal.css">
  <link rel="stylesheet" type="text/css" href="./index.styl">
  <link rel="stylesheet" type="text/css" href="../node_modules/highlight.js/styles/vs.css">
  <title>Dependency Injection: Расширяем область применения</title>
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <section id="title">
        <h1 class="f3 fw-300 gray mb2">Dependency Injection</h1>
        <p class="">Расширяем область применения</p>
      </section>

      <section id="goals">
        <h1 class="f3 fw-300 gray mb3">Цели доклада</h1>
        <ol>
          <li class="mb2 fragment">Сформулировать ключевую идею лежащую в основе DI</li>
          <li class="mb2 fragment">Представить новый контейнер</li>
        </ol>
        <aside class="notes">
          В этом докладе мы хотим представить новый контейнер.
          Он весьма не похож на традиционные Java контейнеры
          и обладает важной особенностью, которая позволяет применять
          ключевую идею, лежащую в основе DI, более широко и с большим успехом.
          <br><br>
          С формулировки ключевой идеи DI (а так же такой системы сборки как Make)
          мы и начнём...
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre><code class="javascript"><include src="./examples/abc.js"/></code></pre>
          <img src="./examples/abc.svg" class="ml5" style="height: 70%; opacity: 0.7;">
        </div>
        <aside class="notes">
          Для этого посмотрим на наш код не как на некую последовательность действий,
          а как на граф, вершины которого обозначают элементарные операции,
          а рёбра их непосредственную зависимость от результатов других операций.
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre class="fragment"><code class="javascript"><include src="./examples/simple.js"/></code></pre>
          <img src="./examples/simple.svg" class="ml4" style="height: 70%; opacity: 0.7;">
        </div>
        <aside class="notes">
          В самом оптимистичном случае такой граф будет представлять собой дерево.
          Дерево замечательно тем, что для его реализации нам достаточно самых базовых
          приёмов программирования. Действительно, если операций станет слишком много,
          мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
          оставаться простой.
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre><code class="javascript"><include src="./examples/complex.js"/></code></pre>
          <img src="./examples/complex.svg" class="ml6 fragment" style="height: 80%; opacity: 0.7;">
        </div>
        <aside class="notes">
          Посмортим, что будет в пессимичном случае...
          <br><br>
          Для этого рассмотрим следующий псевдокод (let result = ...).
          С математической точки зрения, алгоритм полностью определён, состоит из простых элементов,
          но кто в течении нескольких секунд сможет с лёгкостью определить их правильный порядок?
          А если таких выражений будет 100 или 1000?
          <br><br>
          Что интересно, единственно как мы можем запрограммировать такой граф, это
          кропотливо записать элементарные операции в едином монолитном куске кода.
          Действительно, любая попытка разбить его на отдельные подпрограммы
          приведёт только к усложнению (ведь кол-во входных/выходных параметров будет не меньшим чем кол-во объединённых операций),
          а небольшие изменения в спецификации скорее всего разрушат всю концепцию отдельно взятого разбиения.
          <br><br>
          Естественно, мы можем не программировать порядок вручную.
          Приведём пример того, как это может выглядеть...
        </aside>
      </section>

      <section class="size-full">
        <div class="flex align-items-center size-full">
          <pre><code class="javascript"><include src="./examples/container.js"/></code></pre>
          <img src="./examples/complex.svg" class="ml6" style="height: 80%; opacity: 0.7;">
        </div>
        <aside class="notes">
          В начале мы определим наши элементарные действия обычным спрособом,
          а затем при помощи выражения `app.compile()` попросим контейнер
          скомпилировать функцию, которая возвращает `result`, а в качестве параметров
          принимает готовые значения `a` и `b`.
          <br><br>
          Заметьте, что наш код будет оставаться простым независимо
          от кол-ва элементарных операций и сложности их взаимозависимости.
          <br><br>
          Это и есть ключевая идея лежащая в основе DI.
        </aside>
      </section>

      <section>
        <aside class="notes">
          У тех, кто только начинает знакомиться с DI, к этому моменту может возникнуть
          жгучее желание попробовать применить это на практике.
          Действительно, давайте попробуем...
        </aside>
      </section>

      <section style="margin-top: -2%">
        <pre><code class="javascript"><span class="fragment">app.def('response', (user) => `Hello ${user}!`)</span>

<span class="fragment">app.def('user', (db, cookies) => db.getUser(cookies.user)))</span>

<span class="fragment">app.def('cookies', (req) => parse(req.headers['Cookie'])))</span>

<span class="fragment">app.def('db', () => open('mysql://...'))</span>

<span class="fragment">app.def('main', function(Response) {
  http.createServer(function(req, res)) {
    let msg = Response(req)
    res.setHeader('Content-Type', 'text/plain');
    res.end(msg);
  })
})</span>

<span class="fragment">app.level('Response', 'response', ['req']) // Уровень !!!

app.compile('main')(); // Запускаем</span></code></pre>

        <aside class="notes">
          <p>
            Представим в общих чертах бэкэнд типичного WEB-приложения и предположим, что всё,
            что нам нужно, это выводить текстовую страницу с приветствием.
          </p>
          <p>
            Определим текст ответа
          </p>
          <p>...</p>
          <p>
            Определим подключение к БД.
          </p>
          <p>
            Определим способ запуска сервера.
            Как видим, теперь нам недостаёт только функции `Response`,
            которая должна принимать `req` и возвращать приветственную страницу,
            причём вся информация о её формировании в контейнере уже имеется.
          </p>
          <p>
            Механизм, который позволит нам определить эту функцию, мы назовём уровнем.
          </p>
          <p>
            При помощи выражения `app.level('Response', 'response', ['req'])` мы указали, что нам
            нужна функция `Response`, которая возвращает `response`
            принимая в качестве аргумента готовое значение `req`.
            Т.е. передали всё тоже самое же, что и методу `.compile()`.
          </p>
        </aside>
      </section>

      <section>
        <aside class="notes">
          <p>
            Как это всё работает.
          </p>
          <p>
            3. При вызове уровня, каждый раз выполняются только те подзадачи, которые непосредственно зависят
            от начальных аргументов. Все остальные кэшируются на уровнях ниже.
          </p>
        </aside>
      </section>

    </div>
  </div>
  <script type="text/javascript" src="./index.js"></script>
</body>
</html>