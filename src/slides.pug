mixin code
  span.inline-code
    block


mixin arr
  span.arrow &#x27f6


section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.header.mb1 Dependency Injection
      p Расширяем область применения

  aside.notes
    p.
      Символ #[+arr] в комментариях означает,
      что прежде чем читать дальше нужно открыть
      скрытый фрагмент.
    p.
      Предполагается, что вы будете прежде всего
      читать комментарии (как обычную статью),
      обращаясь к слайдам, когда это необходимо.

section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Цели доклада
    ol
      li.mv2 Сформулировать ключевую идею лежащую в основе DI
      li.mv2 Представить новый контейнер
      li.mv2 Обсудить его реализацию

  aside.notes
    p.
      В этом докладе мы хотим представить новый контейнер.
      Он весьма не похож на традиционные Java контейнеры
      и обладает важной особенностью, которая позволяет применять
      ключевую идею, лежащую в основе DI, более широко и с большим успехом.
    p.
      С формулировки ключевой идеи DI мы и начнём...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/abc.js
    .example-graph.ml4
      include examples/abc.svg

  aside.notes
    p.
      Для этого посмотрим на наш код не как на некую последовательность действий,
      а как на граф, вершины которого обозначают элементарные операции,
      а рёбра их непосредственную зависимость друг от друга.


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph
      include examples/simple.svg
    pre.ml5.fragment(style="padding-top: 3%"): code.javascript
      include examples/simple.js

  aside.notes
    p.
      В самом оптимистичном случае такой граф будет представлять собой дерево.
    p.
      Дерево замечательно тем, что для его реализации достаточно самых базовых
      приёмов программирования.
    p.
      Действительно, если операций станет слишком много,
      мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
      оставаться простой. #[+arr]


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/complex.js
    .example-graph.ml4.fragment
      include examples/complex.svg

  aside.notes
    p.
      Посмортим, что будет в более сложном случае.
      Для этого рассмотрим псевдо-код на слайде.
    p.
      С математической точки зрения спецификация проста и понятна,
      но насколько легко вы сможете расставить эти выражения в правильном
      порядке? А если таких выражений будет 100 или 1000?
      Для данного конкретного примера правильный порядок подскажет граф слева. #[+arr]
    p.
      Что интересно, единственно как мы можем запрограммировать такой граф, это
      кропотливо записать элементарные операции в едином монолитном куске кода.
      Действительно, любая попытка разбить его на отдельные подпрограммы
      приведёт только к усложнению, а небольшие изменения в требованиях
      могут разрушить всю концепцию отдельно взятого разбиения.
    p.
      Естественно, мы можем не программировать порядок вручную.
      Приведём пример того, как это может выглядеть...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/container.js
    .example-graph.ml4
      include examples/complex.svg

  aside.notes
    p.
      В начале мы определим наши элементарные выражения обычным спрособом,
      а затем при помощи выражения #[+code app.compile()] попросим контейнер
      скомпилировать функцию, которая возвращает #[+code result], а в качестве параметров
      принимает готовые значения #[+code a] и #[+code b].
    p.
      Заметьте, что наш код будет оставаться простым независимо
      от кол-ва элементарных операций и сложности их взаимозависимости.
    p.
      Это и есть ключевая идея лежащая в основе DI.


section
  .fullsize.flex.align-items-center.pad-center
    h1.header Переходим к практике...

  aside.notes
    p.
      Мы только что обсудили инструмент, который позволяет
      кардинально упростить реализацию программ определённой структуры.
      Тем не менее, если попробовать применить его на практике,
      то окажется, что он полезен не так уж и часто. Вернее, будет казаться,
      что чего-то не хватает.
    p.
      Продемонстируем проблему и её решение смоделировав разработку реального
      приложения.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      span.fragment app.def('response', (user) => `Hello ${user}!`)
      |
      |
      |
      span.fragment app.def('user', (db, cookies) => db.getUser(cookies.user))
      |
      |
      |
      span.fragment app.def('cookies', (req) => parse(req.headers['Cookie']))
      |
      |
      |
      span.fragment
        | app.def('db', (connString) => open(connString))
        |
        | app.def('connString', () => process.ENV.DB_URL)
      |
      |
      |
      span.fragment.
        app.def('main', function(Response) {
          http.createServer(function(req, res)) {
            let msg = Response(req)
            res.setHeader('Content-Type', 'text/plain');
            res.end(msg);
          })
        })

  aside.notes
    p.
      Представим бэкэнд типичного WEB-приложения и начнём его определять.
    p.
      #[+arr] Предположим, что всё, что нам нужно - это выводить текстовую страницу с приветсвием
      для текущего пользователя.
    p.
      #[+arr] Информацию о пользователе мы будем подгружать из некой БД.
    p.
      #[+arr] Cookies получаем разбором заголовка Cookie текущего запроса.
    p.
      #[+arr] Обычным образом открываем соединение с БД.
    p.
      #[+arr] Определяем сервер.
    p.
      Как видим, для запуска приложения нам недостаёт только функции #[+code Response],
      которая должна принимать #[+code req] и возвращать приветственную страницу,
      причём её полная спецификация в контейнере уже имеется.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/web-bad.js

  aside.notes
    p.
      Мы могли бы определить #[+code Response] вручную,
      как это показано на данном слайде, но такой подход плохо масштабируется.
    p.
      Действительно, в реальном приложении кол-во аргументов функции #[+code Response]
      может достигать десятков и сотен, а их состав постоянно меняться.
    p.
      Существуют и другие сложности, которые мы сейчас не будем обсуждать,
      потому что сразу перейдём к правильному решению.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript app.level('Response', 'response', ['req']) // Уровень!

  aside.notes
    p.
      При помощи выражения на слайде мы указали,
      что нам нужна функция #[+code Response],
      которая принимает в качестве аргумента готовое значение #[+code req]
      и возвращает #[+code response]. Определённую таким образом функцию мы
      будем называть уровнем.
    p.
      Уровень является полноправным элементом графа.
      Т.е. его можно свободно использовать при определении
      других подзадач и даже вызывать рекурсивно.
    p.
      Посмотрим как это работает...


section
  .fragment(data-state="highlight-req")
  .fragment(data-state="highlight-dep")
  .fullsize.flex.align-items-center.pad-center
    .flex.fullwidth
      .example-graph.width-1of2
        include examples/web-response.svg
      .example-graph.fragment
        include examples/web.svg

  aside.notes
    p.
      На слайде представлена часть графа,
      относящаяся к вычислению #[+code response].
    p.
      В ней легко можно выделить узлы, которые зависят от
      начальных аргументов уровня (#[+code Response]). Про такие узлы мы будем говорить,
      что они принадлежат уровню. #[+arr]
    p.
      Из оставшейся части графа выделим те, которые являются непосредственными
      зависимостями узлов уровня - это зависимости уровня. #[+arr]
    p.
      Подграф, относящийся к вычислению #[+code main] теперь выглядит так. #[+arr]
    p.
      Мы будем отображать зависимости уровня пунктиром, потому что они "ленивые".
      Действительно, уровень может быть вызван, а может и нет.
      Соответсвенно, зависимости могут понадобиться, а могут и нет.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/Level.js

  aside.notes
    p.
      Представим возможную схему компиляции.
    p.
      // 1. Конструктор принимает начальные аргументы и вызывающий уровень.
    p.
      // 2. Далее идут геттеры для результатов подзадач,
      которые могут понадобиться выше в стеке (зависимости #[+code Qux]).
      Среди них могут быть те, которые определены на данном уровне (зависят от начальных аргументов) (#[+code baz]),
      а так же те, которые должны быть определены ниже в стеке (#[+code bar])
    p.
      // 3. Метод #[+code main] вычисляет результат уровня.
      В целом методы #[+code main] и #[+code compute_*] компилируются обычным способом.
    p.
      // 4. Демонстрация вызова дочернего уровня.


section
  .fullsize.flex.align-items-center.pad-center
    h1.header Killer feature...

  aside.notes
    p.
      Тот факт, что наш контейнер автоматически распределяет
      подзадачи по уровням и не накладывает никаких особых ограничений
      на возможный стек вызовов, является существенным преимуществом
      по сравнению с традиционными Java-контейнерами.
    p.
      Мы попытаемся показать это на простом примере.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      span.
        app.def('jsonSpaces', () => process.ENV.production ? 0 : 2)

        app.def('jsonString', function(jsonSpaces, jsonObject) {
          return JSON.stringify(jsonObject, null, jsonSpaces)
        })

        app.level('stringify', 'jsonString', ['jsonObject'])
      |
      |
      |
      span.fragment.
        // Всё, что нужно изменить для поддержки красивых ответов.
        app.def('jsonSpaces', function(req) {
          return process.ENV.production && !req.query.pretty ? 0 : 2
        })
  aside.notes
    p.
      Популярный WEB-фреймворк express
      определяет глобальный параметр #[+code json spaces]
      отвечающий за форматирование JSON ответов.
      По умолчанию он выставлен как 2 в режиме разработки и 0 в продуктиве.
    p.
      В контейнере эта часть функционала может выглядеть как показано на слайде.
    p.
      Предположим, что позже мы захотели добавить поддержку красивых ответов.
      Т.е. каждый раз, когда в URL запроса присутствует параметр #[+code pretty=true]
      возвращать отформатированный JSON.
    p.
      Для этого достаточно изменить 1 строчку! #[+arr]
    p.
      Используй мы традиционный контейнер,
      нам пришлось бы кропотливо отслеживать все зависимости #[+code jsonSpaces]
      и переносить их на другой уровень вручную.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Достижения
    ol
      li.mv2.fragment Работали с фундаментальной структурой вычисления, а не терминами ООП
      li.mv2.fragment Ввели понятие уровня
      li.mv2.fragment Устранили Runtime потери на вызов подзадач
      li.mv2.fragment Использовали простую структуру данных для их описания

  aside.notes
    p.
      Прежде чем перейти ко второй части доклада
      (обсуждению реализации прототипа) резюмируем наши достижения.
    p.
      #[+arr] 1. Формулировка идеи DI и примеры API подчёркивали
      фундаментальную структуру алгоритма, а не термины ООП.
    p.
      #[+arr] 2. Что позволило нам переосмылслить понятие уровня
      и существенно увеличить мощность паттерна.
    p.
      #[+arr] 3. Собственно, мы ещё ничего не устранили,
      но эта цель игнорируется традиционными контейнерами,
      что является ошибкой. Действительно, используя контейнер,
      мы пытаемся абстрагироваться от сложности взаимозависимости
      элементарных подзадач, однако, наивно полагать, что сложно связаны
      между собой могут быть только тяжёлые задачи.
    p.
      #[+arr] 4. Этот ещё один аспект, которого мы не касались,
      и который и в дальнейшем оставим без внимания.
      Но, всё же, следует отметить, что контейнер должен
      принимать на вход хорошо задокументированную и простую структуру данных,
      что существенно расширит возможности её повторного использования
      в непредвиденных ранее контекстах. Например, некоторые приложения
      могут потребовать альтернативной реализации компилятора,
      легче будет ввести правило вида "Залогировать результаты подзадач, имена которых удовлетворяют определённому шаблону",
      и.т.п.
    p.
      Аспекты, перечисленные на этом слайде,
      в совокупности и являются тем стоп-фактором,
      который мешает более широкому применению традиционных DI-контейнеров.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header Реализация прототипа...

  aside.notes
    p.
      В заключении мы обсудим решения
      принятые при разработке прототипа,
      но ограничимся только вопросом производительности.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 How to build zero overhead runtime?
    ol
      li.mv2.fragment Use code generation
      li.mv2.fragment Support async operations in a clever way

  aside.notes
    p.
      #[+arr] 1. Стремление к zero overhead RT означает, что мы должны
      избегать динамических вызовов функций и доступов
      используя кодо-генерацию.
    p.
      #[+arr] 2. В случаи с JavaScript мы не можем обойтись без встроенной
      поддержки асинхронных операций. Действительно, в любой момент,
      любая задача может стать асинхронной, а контейнер предоставляет
      хорошую возможность оградиться от каскада ненужных изменений.
    p.
      И так, асинхронные операции...


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Замечания по поводу асинхронности
    ol
      li.mv2.fragment Вызов уровня всегда асинхронный
      li.mv2.fragment Много операций с async интерфейсом, но синхронным результатом
    div.fragment
      .gray.f2.mv2.text-align-center &#x21D3
      ol
        li.mv2 Нельзя использовать стандартный Promise API
        li.mv2.fragment Необходима кастомная реализация async/await блоков

  aside.notes
    p.
      Несколько замечаний...
    p.
      #[+arr] 1. Мы вынуждены использовать для вызова уровня асинхронный API,
      поскольку его истинная синхронность/асинхронность может легко поменяться,
      а мы не хотим, чтобы локальный код от этого зависел.
    p.
      #[+arr] 2. Другим примером потенциально (а возможно и часто) синхронной операции
      с асинхронным интерфейсом является вызов асинхронной подзадачи нижележащего уровня.
      Такой вызов будет асинхронным только в первый раз,
      в последующем результат будет немедленно доступен.
    p.
      #[+arr] Большое кол-во синхронных задач с асинхронным интерфейсом означает,
      что мы не можем использовать Promise API.
      Действительно, стандартный Promise позволяет запросить результат только через event-loop,
      а это означает катострофу для производительности.
    p.
      #[+arr] Точно таким же недостатком обладают и ES8 async функции.
      Это может стать проблемой, если мы захотим их использовать для работы с уровнями.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Быстрые async/await блоки
    div: a(href="https://github.com/eldargab/go-async") https://github.com/eldargab/go-async

  aside.notes
    p.
      Специально для решения ранее указанных проблем была разработана
      библиотека #[+code go-async].
    p.
      Синхронные вызовы в её async/await болках, основанных на генераторах,
      стоят примерно 30 - 100 наносекунд.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Async code generation variants
    ol
      li.mv2.fragment Async/await блоки основанные на генераторах
      li.mv2.fragment Комбинация кэширования и исключений
      li.mv2.fragment Комбинация кэширования и проверок

  aside.notes
    p.
      Прежде чем рассмотреть возможные варианты генерации асинхронного
      кода следует отметить, что мы могли бы сильно поднять производительность
      используя ручную аннотацию асинхронных операций. В прототипе от этого
      было решено отказаться.
    p.
      И так варианты.
    p.
      #[+arr] 1. Стоимость подзадачи 30..100 ns.
    p.
      #[+arr] 2. Стоимость синхронной подзадачи 10 ns, асинхронной - 5 mcs.
    p.
      #[+arr] 3. Стоимость синхронной подзадачи 15 ns, асинхронной - 100 ns.
    p.
      Мы выберем второй вариант, поскольку настоящая асинхронная операция,
      уже сама по себе подразумевает серьёзную стоимость.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Вариант 2
    pre: code.javascript(style="font-size: 0.6rem")
      include examples/async.js

  aside.notes
    p.
      Вариант 3 полностью аналогичен, за исключением того,
      что вместо исключений используются явные сравнения
      промежуточных значений с #[+code undefined].


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Прототип
    div: a(href="https://github.com/eldargab/easy-app") https://github.com/eldargab/easy-app

  aside.notes
    p.
      Изложенные в докладе идеи реализованы в проекте #[+code easy-app].


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 Спасибо за внимание!

  aside.notes
    p.
      На этом всё, спасибо за внимание!
    p.
      P.S. Содержание второй части доклада может быть сильно
      изменено по мере готовности WEB-фреймворка на основе
      представленного контейнера.
