mixin code
  span.inline-code
    block


mixin arr
  span.arrow &#x27f6


section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.header.mb1 dar.container
      p IoC programming framework

  aside.notes
    p.
      При выборе названия доклада я долго сомневался.
      С одной стороны опыт общения с разработчиками подсказывал,
      что лучше избегать таких слов как "Dependency injection"
      или "IoC контейнер", поскольку они сразу же провоцируют ассоциации
      не с тем о чём данный доклад, с другой - о Dependency injection
      и пойдёт речь, с той лишь разницей, что "control flow" будет более
      богатой структуры, да и "use case" несколько отличаться.
    p.
      Символ #[+arr] в комментариях означает,
      что прежде чем читать дальше нужно открыть
      скрытый фрагмент.

section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 План
    ol
      li.mv2 Базовая идея
      li.mv2 Доработка идеи
      li.mv2 Реализация, использование, сравнение и итоги.

  aside.notes
    p.
      Первая часть доклада может показаться тривиальной,
      но обозначить базовую идею всё же стоит.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/abc.clj
    .example-graph.ml4
      include examples/abc.svg

  aside.notes
    p.
      Для этого посмотрим на наш код как на граф,
      вершины которого обозначают результаты элементарных операций,
      а рёбра их аргументы.


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph
      include examples/simple.svg
    pre.ml5.fragment(style="padding-top: 3%"): code.javascript
      include examples/simple.clj

  aside.notes
    p.
      В простейшем случаи такой граф будет представлять собой дерево.
    p.
      Дерево замечательно тем, что для его реализации достаточно самых базовых
      приёмов программирования.
    p.
      Действительно, если операций станет слишком много,
      мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
      оставаться простой. #[+arr]
    p.
      Посмортим, что будет в более сложном случае...


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph.mr4
      include examples/complex.svg
    pre: code.clojure.fragment
      include examples/complex.clj

  aside.notes
    p.
      Здесь любая попытка выделить несколько узлов
      в отдельную функцию приведёт лишь к увеличению сложности.
    p.
      Для того, что бы в этом убедиться достаточно посмотреть
      на любой подграф состоящий из нескольких узлов
      и сравнить кол-во входящих/исходящих рёбер
      с кол-вом рёбер, которые остались внутри.
    p.
      Ситуация осложняется ещё и тем, что конкретная структура
      связей в подобных графах носит "случайный" характер.
      Т.е. даже если какое-то осмысленное разбиение на более крупные
      компоненты существует сегодня, оно может быть разрушено
      завтра в виду простого и невинного изменения требований.
    p.
      Самой простой реализацией такого графа будет монолитная последовательность
      элементарных операций расставленных в правильном порядке.
      #[+arr]
    p.
      Естественно, программировать и поддерживать такой код
      вручную будет проблематично, особенно если граф большой,
      а требования меняются часто. Отсюда идея - использовать
      инструмент, который проанализирует структуру связей и сгенерирует
      оптимальный код за нас.

section
  .fullsize.flex.align-items-center.pad-center
    .example-graph.mr4
      include examples/complex.svg
    pre: code.clojure
      span.fragment.
        (define app :result :args [:abcd :xy] :fn +)
        (define app :abcd   :args [:b :ab]    :fn +)
        (define app :ab     :args [:b :a]     :fn +)
        (define app :cd     :args [:b :a]     :fn +)
        (define app :d      :args [:abcd :ab] :fn +)
        (define app :x      :args [:d :cd]    :fn +)
        (define app :xy     :args [:abcd :x]  :fn +)
      |
      |
      |
      span.fragment.
        (def result
          (compile-app app :result [:a :b]))

        (result 1 1) ; => 13

  aside.notes
    p.
      Это может выглядеть следующим образом...
    p.
      Сперва определим граф. #[+arr]
    p.
      После этого мы попросим инструмент скомпилировать
      функцию, которая будет принимать :a и :b
      и возвращать :result. #[+arr]
    p.
      Несмотря на то, что инструменты подобного рода
      хорошо известны и широко используются, можно
      заметить, что речь идёт о поддержке кода весьма определённой структуры.
      Мы не можем создать аналоги таких конструкции как стеки, замыкания, и.т.п.,
      в то время как необходимость в них возникает практически сразу.
    p.
      Покажем это на примере.
      Для этого представим бэкэнд типичного WEB-приложения...

section
  .fullsize.flex.align-items-center.pad-center
    pre: code.clojure
      span.
        (define app :response
          :args [:user]
          :fn #(str "Hello " %))

        (define app :user
          :args [:db :req]
          :fn (fn [db req]
                (get-user db (-> req :query :user))))

        (define app :db
          :args [:config]
          :fn #(open (:connection-string %)))

        (define app :config
          :fn #(read "config.edn"))

  aside.notes
    p.
      С математической точки зрения приложение определено и понятно,
      но как использовать такую спецификацию?


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph(style="margin-right: 80px")
      include examples/web.svg
    div
      .fragment
        h1.sub-header.mb3 Вариант 1
        pre: code.clojure.
          (def response
            (compile-app :response [:req]))
      .fragment
        h1.sub-header.mt4.mb3 Вариант 2
        pre: code.clojure.
          (def response
            (compile-app :response [:req :db]))

          (define app :main
            :args [:db]
            :fn (fn [db]
                  (run-server (fn [req]
                                (response req db)))))

          ((compile-app app :main [])) ; run the server

  aside.notes
    p.
      "Из коробки" у нас есть два варианта:
    p.
      1. "В стиле PHP" #[+arr]
    p.
      Т.е. используем :response в качестве точки входа и
      пересчитываем всё что нужно при каждом запросе.
    p.
      2. Отслеживаем зависимости вручную #[+arr]
    p.
      Несмотря на то, что в данном конкретном примере всё просто,
      не трудно представить вместо :db длинный список параметров,
      а вместо двух-уровневого приложения стек из многих уровней, где каждый
      должен получить не только свои зависимости, но и зависимости всех уровней,
      которые он вызывает.
    p.
      Так же следует заметить, что в случаи применения второго варианта
      теряется возможность сборки приложения из нескольких частей путём
      простого слияния определений в один граф, так как любое такое
      слияние может изменить зависимости того или иного уровня.
    p.
      Нам не зачем идти на компромисы, поскольку существует оптимальное решение!


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph(style="margin-right: 80px")
      include examples/web.svg
    div
      h1.sub-header.mb3 Уровень!
      pre: code.clojure.
        (define-level app :req-handler :response [:req])

        (define app :main
          :args [:req-handler]
          :fn run-server)

        ((compile-app app :main [])) ; run the server

  aside.notes
    p.
      При помощи выражения #[+code define-level] мы
      определили ещё один узел графа. Его runtime значением
      является функция, которая принимает #[+code :req] и
      возвращает #[+code :response].
    p.
      Уровень отличается от всех остальных узлов только тем,
      что его определение и зависимости выводятся инструментом автоматически.
      Во всём остальном это обычное значение, которое мы можем свободно
      использовать.


section
  .fragment(data-state="highlight-red")
  .fragment(data-state="highlight-green")
  .fullsize.flex.align-items-center.pad-center
    .flex.fullwidth
      .example-graph.width-1of2
        include examples/web.svg
      .example-graph.fragment
        include examples/web-main.svg

  aside.notes
    p.
      Как это работает.
    p.
      На слайде представлена часть графа,
      относящаяся к вычислению #[+code :response].
    p.
      В ней легко можно выделить узлы, которые зависят от
      начальных аргументов уровня. #[+arr]
      Про такие узлы мы будем говорить, что они принадлежат уровню.
    p.
      Из оставшейся части графа выделим те, которые являются непосредственными
      зависимостями узлов уровня - это зависимости уровня. #[+arr]
    p.
      Подграф, относящийся к #[+code :main], теперь выглядит так #[+arr]


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.clojure
      span.fragment.
        (define app :serialize
          :args [:config]
          :fn (fn [{production? :production?}]
                (if production?
                  pr-str
                  pprint-str)))
      |
      |
      |
      |
      span.fragment.
        (define app :serialize
          :args [:req :config]
          :fn (fn [req {production? :production?}]
                (if (and production? (not (-> req :query :pretty)))
                  pr-str
                  pprint-str)))

  aside.notes
    p.
      Покажем гибкость и удобство получившейся системы на простом,
      но достаточно реалистичном примере.
    p.
      Предположим, что нам потребовалось возвращать пользователям
      EDN ответы. Для этого определим функцию #[+code serialize],
      которая будет принимать значение для сериализации и возвращать строку.
      Так же, предположим, что для облегчения отладки во время разработки
      мы хотим видеть красиво отформатированные ответы. В первом приближении
      определение может иметь следующий вид #[+arr]
    p.
      #[+code serialize] вычисляется один раз за время
      работы приложения, а затем повторно используется.
    p.
      Теперь предположим, что мы захотели видеть красивые ответы даже
      в продуктиве если в URL присутствует параметр #[+code pretty].
      Всё, что для этого нужно - это немного изменить определение! #[+arr]


section
  .fullsize.flex.align-items-center.pad-center
    a(href="https://github.com/dar-clojure/container") https://github.com/dar-clojure/container

  aside.notes
    p.
      Все показанные ранее примеры реально работают :)
    p.
      Вкратце пробежимся по прочим деталям библиотеки, которые не меняют
      общей картины, но важны для практического использования...


section
  .fullsize.flex.align-items-center.pad-center: .flex.flex-col
    .flex.fullwidth
      .fragment(style="margin-right: 120px")
        h1.sub-header.mb2 Lazy arguments
        pre: code.clojure.
          (define app :b-or-c
            :args [:a :b :c]
            :lazy \#{:b :c}
            :fn (fn [a b c]
                  (if a
                    (b)
                    (c))))

      .fragment
        h1.sub-header.mb2 Dynamic evaluation
        pre: code.clojure.
          (define app :b-or-c
            :args [:a :eval]
            :uses \#{:b :c}
            :fn (fn [a eval]
                  (if a
                    (eval :b)
                    (eval :c))))
    .flex.fullwidth(style="margin-top: 80px")
      .fragment(style="margin-right: 120px; min-width: 260px")
        h1.sub-header.mb2 PRE arguments
        pre: code.clojure.
          (define app :ab
            :pre [:x :y]
            :args [:a :b]
            :fn (fn [a b]
                  (+ a b)))
      .fragment
        h1.sub-header.mb2 Control flow
        ul
          li.mb2.f-small.fragment Execution order is strictly defined.
          li.f-small.fragment Each node is calculated only when absolutly required.

  aside.notes
    p.
      Lazy arguments #[+arr]
    p.
      Dynamic evaluation #[+arr]
    p.
      PRE arguments #[+arr]
    p.
      PRE arguments - список узлов,
      которые должны быть выполненны до запуска текущего узла
      и вычисления его аргументов.
    p.
      Control flow #[+arr]
    p.
      #[+arr]
      Порядок вычисления узлов строго определён отношениями
      зависимости, а так же списками #[+code :pre] и #[+code :args].
    p.
      #[+arr]
      Каждый узел (за время выполнения уровня) вычисляется строго один раз и
      только тогда, когда это строго необходимо.
    p.
      Т.е, например, создание функции-уровня для передачи в качестве аргумента
      какому либо узлу не приводит к предварительному вычислению зависимостей уровня.


section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.sub-header.mb2 Closables
      pre: code.clojure.
        (define app :file
          :close #(.close %) ; Guaranteed to be called right before level exit
          :fn #(open "file.txt"))

  aside.notes
    p.
      Исключением из правила является главный узел уровня.
      В этом случаи атрибут #[+code :close] игнорируется.


section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.sub-header.mb2 Thread safety
      p.mb4.
        Uses lock-based synchronization for shared level-state if such is present.
      pre: code.clojure.
        (if (. state isReadyA)
          (. state A)
          (locking state
            (if (. state isReadyA)
              (. state A)
              (let [v (compute-A state)]
                (set! (. state A) v)
                (set! (. state isReadyA) true)
                v))))

  aside.notes
    p.
      Класс для хранения состояния уровня (и соотвественно код изображённый на слайде)
      создаётся только в случаи необходимости.
    p.
      В простешем случаи код уровня
      представляет собой простую последовательность выражений #[+code let].


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.header.mb3 dar.container vs DI
    table.table
      thead
        tr
          th Feature
          th dar.container
          th Traditional DI
      tbody
        tr
          td.fw-600.gray Primary use case
          td Solve a certain structural problem.
          td Make things configurable, overridable, facilitate app initialization.
        tr
          td.fw-600.gray Evaluation strategy
          td.
            Compilation to efficient code is a must.
            Even light functions can have a complex
            control flow.
          td Dynamic evaluation mostly.
        tr
          td.fw-600.gray Support for levels
          td It's a main feature!
          td Very limited and quirky in form of scopes.

  aside.notes
    p.fw-600.
      Make things configurable...
    p.
      Если посмотреть на инструменты популярные в Clojure
      community (например https://github.com/tolitius/mount),
      то там речь идёт о старте определённых частей приложения,
      перезагрузке определённых частей, и.т.п, что может быть удобно
      при интерактивной разработки. Подобный функционал вне объёма проекта.
      Здесь речь идёт не а каком-то принципиальном ограничении, а о разных
      интерпретациях одной и той же струтктуры данных,
      и одна их них остаётся за бортом.
    p.fw-600.
      Support for levels is very limited and quirky...
    p.
      Механизм скопов в традиционных DI контейнерах
      по крайней мере требует ручной аннотации
      принадлежности каждого узла тому или иному скопу,
      что эквивалентно ситуации с ручным отслеживанием
      зависимостей уровня (Вариант 2 из доклада).
      Помимо этого, реализация стека из нескольких уровней
      требует учёта целого рядя странностей,
      своих для каждого контейнера.


section
  .fullsize.flex.align-items-center.pad-center
    h1.header Спасибо за внимание!
