section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.f3.fw-300.gray.mb1 Dependency Injection
      p Расширяем область применения


section
  h1.f3.fw-300.gray.mb3 Цели доклада
  ol
    li.mb2.fragment Сформулировать ключевую идею лежащую в основе DI
    li.mb2.fragment(data-fragment-index=1) Представить новый контейнер

  aside.notes
    p.
      В этом докладе мы хотим представить новый контейнер.
      Он весьма не похож на традиционные Java контейнеры
      и обладает важной особенностью, которая позволяет применять
      ключевую идею, лежащую в основе DI, более широко и с большим успехом.
    p.
      С формулировки ключевой идеи DI мы и начнём...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/abc.js
    .example-graph.ml4
      include examples/abc.svg

  aside.notes
    p.
      Для этого посмотрим на наш код не как на некую последовательность действий,
      а как на граф, вершины которого обозначают элементарные операции,
      а рёбра их непосредственную зависимость друг от друга.


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph
      include examples/simple.svg
    pre.ml5.fragment(style="padding-top: 3%"): code.javascript
      include examples/simple.js

  aside.notes
    p.
      В самом оптимистичном случае такой граф будет представлять собой дерево.
      Дерево замечательно тем, что для его реализации нам достаточно самых базовых
      приёмов программирования. Действительно, если операций станет слишком много,
      мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
      оставаться простой.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/complex.js
    .example-graph.ml4.fragment
      include examples/complex.svg

  aside.notes
    p.
      Посмортим, что будет в более сложном случае.
      Для этого рассмотрим следующий псевдо-код.
    p.
      С математической точки зрения спецификация проста и понятна,
      но насколько легко вы сможете расставить эти выражения в правильном
      порядке? А если таких выражений будет 100 или 1000?
      Для данного конкретного примера правильный порядок подскажет граф слева.
    p.
      Что интересно, единственно как мы можем запрограммировать такой граф, это
      кропотливо записать элементарные операции в едином монолитном куске кода.
      Действительно, любая попытка разбить его на отдельные подпрограммы
      приведёт только к усложнению, а небольшие изменения в требованиях
      могут разрушить всю концепцию отдельно взятого разбиения.
    p.
      Естественно, мы можем не программировать порядок вручную.
      Приведём пример того, как это может выглядеть...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/container.js
    .example-graph.ml4
      include examples/complex.svg

  aside.notes
    p.
      В начале мы определим наши элементарные выражения обычным спрособом,
      а затем при помощи выражения `app.compile()` попросим контейнер
      скомпилировать функцию, которая возвращает `result`, а в качестве параметров
      принимает готовые значения `a` и `b`.
    p.
      Заметьте, что наш код будет оставаться простым независимо
      от кол-ва элементарных операций и сложности их взаимозависимости.
    p.
      Это и есть ключевая идея лежащая в основе DI.


section
  .fullsize.flex.align-items-center.pad-center
    h1.f3.fw-300.gray Переходим к практике...

  aside.notes
    p.
      Мы только что обсудили инструмент, который позволяет
      кардинально упростить реализацию программ определённой структуры.
      Тем не менее, если мы попробуем использовать его на практике,
      то обнаружим, что он полезен не так уж и часто. Вернее, нам будет казаться,
      что чего-то не хватает.
    p.
      Продемонстируем проблему и её решение смоделировав разработку реального
      приложения.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      span.fragment app.def('response', (user) => `Hello ${user}!`)
      |
      |
      |
      span.fragment app.def('user', (db, cookies) => db.getUser(cookies.user)))
      |
      |
      |
      span.fragment app.def('cookies', (req) => parse(req.headers['Cookie'])))
      |
      |
      |
      span.fragment
        | app.def('db', (connString) => open(connString))
        |
        | app.def('connString', () => process.ENV.DB_URL)
      |
      |
      |
      span.fragment.
        app.def('main', function(Response) {
          http.createServer(function(req, res)) {
            let msg = Response(req)
            res.setHeader('Content-Type', 'text/plain');
            res.end(msg);
          })
        })

  aside.notes
    p.
      Представим бэкэнд типичного WEB-приложения и начнём его определять.
    p.
      Предположим, что всё, что нам нужно - это выводить текстовую страницу с приветсвием
      для текущего пользователя.
    p.
      Информацию о пользователе мы будем подгружать из некой БД.
    p.
      Cookies получаем разбором заголовка Cookie текущего запроса.
    p.
      Обычным образом открываем соединение с БД.
    p.
      Определяем сервер.
    p.
      Как видим, для запуска приложения нам недостаёт только функции `Response`,
      которая должна принимать `req` и возвращать приветственную страницу,
      причём её полная спецификация в контейнере уже имеется.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/web-bad.js

  aside.notes
    p.
      Мы могли бы определить `Response` вручную,
      как это показано на данном слайде, но такой подход плохо масштабируется.
    p.
      Действительно, в реальном приложении кол-во аргументов функции `Response`
      может достигать десятков и сотен, а их состав постоянно меняться.
    p.
      Существуют и другие сложности, которые мы сейчас не будем обсуждать,
      потому что сразу перейдём к решению.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript app.level('Response', 'response', ['req']) // Уровень!

  aside.notes
    p.
      При помощи выражения на слайде мы указали,
      что нам нужна функция `Response`,
      которая принимает в качестве аргумента готовое значение `req`
      и возвращает `response`. Определённую таким образом функцию мы
      будем называть уровнем.
    p.
      Уровень является полноправным элементом графа.
      Т.е. его можно свободно использовать при определении
      других подзадач и даже вызывать рекурсивно.
    p.
      Посмотрим как это работает...


section
  .fragment(data-state="highlight-req")
  .fragment(data-state="highlight-dep")
  .fullsize.flex.align-items-center.pad-center.justify-content
    .flex.fullwidth
      .example-graph.width-1of2
        include examples/web-response.svg
      .example-graph.fragment
        include examples/web.svg

  aside.notes
    p.
      На слайде представлена часть графа,
      которая относится к вычислению `response`
      (связана с уровнем `Response`).
    p.
      В ней легко можно выделить узлы, которые зависят от
      начальных аргументов уровня. Про такие узлы мы будем говорить,
      что они принадлежат уровню.
    p.
      Из оставшихся узлов выделим те, которые являются непосредственными
      зависимостями узлов уровня - это зависимости уровня.
