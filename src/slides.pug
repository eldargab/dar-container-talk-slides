section
  h1.f3.fw-300.gray.mb2 Dependency Injection
  p Расширяем область применения


section
  h1.f3.fw-300.gray.mb3 Цели доклада
  ol
    li.mb2.fragment Сформулировать ключевую идею лежащую в основе DI
    li.mb2.fragment(data-fragment-index=1) Представить новый контейнер

  aside.notes
    p.
      В этом докладе мы хотим представить новый контейнер.
      Он весьма не похож на традиционные Java контейнеры
      и обладает важной особенностью, которая позволяет применять
      ключевую идею, лежащую в основе DI, более широко и с большим успехом.
    p.
      С формулировки ключевой идеи DI мы и начнём...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/abc.js
    .example-graph.ml4
      include examples/abc.svg

  aside.notes
    p.
      Для этого посмотрим на наш код не как на некую последовательность действий,
      а как на граф, вершины которого обозначают элементарные операции,
      а рёбра их непосредственную зависимость друг от друга.


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph
      include examples/simple.svg
    pre.ml5.fragment(style="padding-top: 3%"): code.javascript
      include examples/simple.js

  aside.notes
    p.
      В самом оптимистичном случае такой граф будет представлять собой дерево.
      Дерево замечательно тем, что для его реализации нам достаточно самых базовых
      приёмов программирования. Действительно, если операций станет слишком много,
      мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
      оставаться простой.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/complex.js
    .example-graph.ml4.fragment
      include examples/complex.svg

  aside.notes
    p.
      Посмортим, что будет в более сложном случае.
      Для этого рассмотрим следующий псевдо-код.
    p.
      С математической точки зрения спецификация проста и понятна,
      но насколько легко вы сможете расставить эти выражения в правильном
      порядке? А если таких выражений будет 100 или 1000?
      Для данного конкретного примера правильный порядок подскажет граф слева.
    p.
      Что интересно, единственно как мы можем запрограммировать такой граф, это
      кропотливо записать элементарные операции в едином монолитном куске кода.
      Действительно, любая попытка разбить его на отдельные подпрограммы
      приведёт только к усложнению, а небольшие изменения в требованиях
      могут разрушить всю концепцию отдельно взятого разбиения.
    p.
      Естественно, мы можем не программировать порядок вручную.
      Приведём пример того, как это может выглядеть...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/container.js
    .example-graph.ml4
      include examples/complex.svg

  aside.notes
    p.
      В начале мы определим наши элементарные выражения обычным спрособом,
      а затем при помощи выражения `app.compile()` попросим контейнер
      скомпилировать функцию, которая возвращает `result`, а в качестве параметров
      принимает готовые значения `a` и `b`.
    p.
      Заметьте, что наш код будет оставаться простым независимо
      от кол-ва элементарных операций и сложности их взаимозависимости.
    p.
      Это и есть ключевая идея лежащая в основе DI.


section
  .fullsize.flex.align-items-center.pad-center
    h1.f3.fw-300.gray Переходим к практике...

  aside.notes
    p.
      Мы только что рассмотрели инструмент, который позволяет
      кардинально упростить реализацию определённого класса алгоритмов.
      Попробуем проверить на сколько он полезен в реальных приложениях.

