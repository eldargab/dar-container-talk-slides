section
  .fullsize.flex.align-items-center.pad-center
    div
      h1.f3.fw-300.gray.mb1 Dependency Injection
      p Расширяем область применения


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.f3.fw-300.gray.mb3 Цели доклада
    ol
      li.mv2 Сформулировать ключевую идею лежащую в основе DI
      li.mv2 Представить новый контейнер
      li.mv2 Обсудить его реализацию

  aside.notes
    p.
      В этом докладе мы хотим представить новый контейнер.
      Он весьма не похож на традиционные Java контейнеры
      и обладает важной особенностью, которая позволяет применять
      ключевую идею, лежащую в основе DI, более широко и с большим успехом.
    p.
      С формулировки ключевой идеи DI мы и начнём...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/abc.js
    .example-graph.ml4
      include examples/abc.svg

  aside.notes
    p.
      Для этого посмотрим на наш код не как на некую последовательность действий,
      а как на граф, вершины которого обозначают элементарные операции,
      а рёбра их непосредственную зависимость друг от друга.


section
  .fullsize.flex.align-items-center.pad-center
    .example-graph
      include examples/simple.svg
    pre.ml5.fragment(style="padding-top: 3%"): code.javascript
      include examples/simple.js

  aside.notes
    p.
      В самом оптимистичном случае такой граф будет представлять собой дерево.
    p.
      Дерево замечательно тем, что для его реализации достаточно самых базовых
      приёмов программирования.
    p.
      Действительно, если операций станет слишком много,
      мы всегда сможем разбить их на отдельные подпрограммы, каждая из которых будет
      оставаться простой.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/complex.js
    .example-graph.ml4.fragment
      include examples/complex.svg

  aside.notes
    p.
      Посмортим, что будет в более сложном случае.
      Для этого рассмотрим следующий псевдо-код.
    p.
      С математической точки зрения спецификация проста и понятна,
      но насколько легко вы сможете расставить эти выражения в правильном
      порядке? А если таких выражений будет 100 или 1000?
      Для данного конкретного примера правильный порядок подскажет граф слева.
    p.
      Что интересно, единственно как мы можем запрограммировать такой граф, это
      кропотливо записать элементарные операции в едином монолитном куске кода.
      Действительно, любая попытка разбить его на отдельные подпрограммы
      приведёт только к усложнению, а небольшие изменения в требованиях
      могут разрушить всю концепцию отдельно взятого разбиения.
    p.
      Естественно, мы можем не программировать порядок вручную.
      Приведём пример того, как это может выглядеть...


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/container.js
    .example-graph.ml4
      include examples/complex.svg

  aside.notes
    p.
      В начале мы определим наши элементарные выражения обычным спрособом,
      а затем при помощи выражения `app.compile()` попросим контейнер
      скомпилировать функцию, которая возвращает `result`, а в качестве параметров
      принимает готовые значения `a` и `b`.
    p.
      Заметьте, что наш код будет оставаться простым независимо
      от кол-ва элементарных операций и сложности их взаимозависимости.
    p.
      Это и есть ключевая идея лежащая в основе DI.


section
  .fullsize.flex.align-items-center.pad-center
    h1.f3.fw-300.gray Переходим к практике...

  aside.notes
    p.
      Мы только что обсудили инструмент, который позволяет
      кардинально упростить реализацию программ определённой структуры.
      Тем не менее, если мы попробуем использовать его на практике,
      то обнаружим, что он полезен не так уж и часто. Вернее, нам будет казаться,
      что чего-то не хватает.
    p.
      Продемонстируем проблему и её решение смоделировав разработку реального
      приложения.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      span.fragment app.def('response', (user) => `Hello ${user}!`)
      |
      |
      |
      span.fragment app.def('user', (db, cookies) => db.getUser(cookies.user)))
      |
      |
      |
      span.fragment app.def('cookies', (req) => parse(req.headers['Cookie'])))
      |
      |
      |
      span.fragment
        | app.def('db', (connString) => open(connString))
        |
        | app.def('connString', () => process.ENV.DB_URL)
      |
      |
      |
      span.fragment.
        app.def('main', function(Response) {
          http.createServer(function(req, res)) {
            let msg = Response(req)
            res.setHeader('Content-Type', 'text/plain');
            res.end(msg);
          })
        })

  aside.notes
    p.
      Представим бэкэнд типичного WEB-приложения и начнём его определять.
    p.
      Предположим, что всё, что нам нужно - это выводить текстовую страницу с приветсвием
      для текущего пользователя.
    p.
      Информацию о пользователе мы будем подгружать из некой БД.
    p.
      Cookies получаем разбором заголовка Cookie текущего запроса.
    p.
      Обычным образом открываем соединение с БД.
    p.
      Определяем сервер.
    p.
      Как видим, для запуска приложения нам недостаёт только функции `Response`,
      которая должна принимать `req` и возвращать приветственную страницу,
      причём её полная спецификация в контейнере уже имеется.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/web-bad.js

  aside.notes
    p.
      Мы могли бы определить `Response` вручную,
      как это показано на данном слайде, но такой подход плохо масштабируется.
    p.
      Действительно, в реальном приложении кол-во аргументов функции `Response`
      может достигать десятков и сотен, а их состав постоянно меняться.
    p.
      Существуют и другие сложности, которые мы сейчас не будем обсуждать,
      потому что сразу перейдём к правильному решению.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript app.level('Response', 'response', ['req']) // Уровень!

  aside.notes
    p.
      При помощи выражения на слайде мы указали,
      что нам нужна функция `Response`,
      которая принимает в качестве аргумента готовое значение `req`
      и возвращает `response`. Определённую таким образом функцию мы
      будем называть уровнем.
    p.
      Уровень является полноправным элементом графа.
      Т.е. его можно свободно использовать при определении
      других подзадач и даже вызывать рекурсивно.
    p.
      Посмотрим как это работает...


section
  .fragment(data-state="highlight-req")
  .fragment(data-state="highlight-dep")
  .fullsize.flex.align-items-center.pad-center
    .flex.fullwidth
      .example-graph.width-1of2
        include examples/web-response.svg
      .example-graph.fragment
        include examples/web.svg

  aside.notes
    p.
      На слайде представлена часть графа,
      относящаяся к вычислению `response`.
    p.
      В ней легко можно выделить узлы, которые зависят от
      начальных аргументов уровня (`Response`). Про такие узлы мы будем говорить,
      что они принадлежат уровню.
    p.
      Из оставшейся части графа выделим те, которые являются непосредственными
      зависимостями узлов уровня - это зависимости уровня.
    p.
      Подграф, относящийся к вычислению `main` теперь выглядит так.
    p.
      Мы будем отображать зависимости уровня пунктиром, потому что они "ленивые".
      Действительно, уровень может быть вызван, а может и нет.
      Соответсвенно, зависимости могут понадобиться, а могут и нет.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      include examples/Level.js

  aside.notes
    p.
      Представим возможную схему компиляции.
    p.
      // 1. Конструктор принимает начальные аргументы и вызывающий уровень.
    p.
      // 2. Далее идут геттеры для результатов подзадач,
      которые могут понадобиться выше в стеке (зависимости `Qux`).
      Среди них могут быть те, которые определены на данном уровне (зависят от начальных аргументов) (`baz`),
      а так же те, которые должны быть определены ниже в стеке (`bar`)
    p.
      // 3. Метод `main` вычисляет результат уровня.
      В целом методы `main` и `compute_*` компилируются обычным способом.
    p.
      // 4. Демонстрация вызова дочернего уровня.


section
  .fullsize.flex.align-items-center.pad-center
    h1.f3.gray.fw-300 Killer feature...

  aside.notes
    p.
      Тот факт, что наш контейнер автоматически распределяет
      подзадачи по уровням и не накладывает никаких особых ограничений
      на возможный стек вызовов, является существенным преимуществом
      по сравнению с традиционными Java-контейнерами.
    p.
      Мы попытаемся показать это на простом, но всё же жизненном примере.


section
  .fullsize.flex.align-items-center.pad-center
    pre: code.javascript
      span.
        app.def('jsonSpaces', () => process.ENV.production ? 0 : 2)

        app.def('jsonString', function(jsonSpaces, jsonObject) {
          return JSON.stringify(jsonObject, null, jsonSpaces)
        })

        app.level('stringify', 'jsonString', ['jsonObject'])
      |
      |
      |
      span.fragment.
        // Всё, что нужно изменить для поддержки красивых ответов.
        app.def('jsonSpaces', function(req) {
          return process.ENV.production && !req.query.pretty ? 0 : 2
        })
  aside.notes
    p.
      Популярный WEB-фреймворк express
      определяет глобальный параметр `json spaces`
      отвечающий за форматирование JSON ответов.
      По умолчанию он выставлен как 2 в режиме разработки и 0 в продуктиве.
    p.
      В контейнере эта часть функционала может выглядеть как показано на слайде.
    p.
      Предположим, что позже мы захотели добавить поддержку красивых ответов.
      Т.е. каждый раз, когда в URL запроса присутствует параметр `pretty=true`
      возвращать отформатированный JSON.
    p.
      Для этого достаточно изменить 1 строчку!
    p.
      Используй мы традиционный контейнер,
      нам пришлось бы кропотливо отслеживать все зависимости `jsonSpaces`
      и переносить их на другой уровень вручную.


section
  .fullsize.flex.align-items-center.pad-center: div
    h1.f3.gray.fw-300.mb3 Достижения
    ol
      li.mv2.fragment Работали с фундаментальной структурой вычисления, а не терминами ООП
      li.mv2.fragment Ввели понятие уровня
      li.mv2.fragment Устранили Runtime потери на вызов подзадач
      li.mv2.fragment Использовали простую структуру данных для их описания

  aside.notes
    p.
      Прежде чем перейти к обсуждению интересных моментов
      реализации прототипа резюмируем наши достижения.
    p.
      1. Формулировка идеи DI и примеры API подчёркивали
      фундаментальную структуру алгоритма, а не термины ООП.
    p.
      2. Что позволило нам переосмылслить понятие уровня
      и существенно увеличить мощность паттерна.
    p.
      3. Собственно, мы ещё ничего не устранили,
      но эта цель игнорируется традиционными контейнерами,
      что является ошибкой. Действительно, используя контейнер,
      мы пытаемся абстрагироваться от сложности взаимозависимости
      элементарных подзадач, однако, наивно полагать, что сложно связаны
      между собой могут быть только тяжёлые задачи.
    p.
      4. Этот ещё один аспект, которого мы не касались,
      и который и в дальнейшем оставим без внимания.
      Но, всё же, следует отметить, что контейнер должен
      принимать на вход хорошо задокументированную и простую структуру данных,
      что существенно расширит возможности её повторного использования
      в непредвиденных ранее контекстах. Например, некоторые приложения
      могут потребовать альтернативной реализации компилятора, или
      легче будет ввести правило вида "Залогировать результаты подзадач, имена которых удовлетворяют определённому шаблону",
      и.т.п.
    p.
      Аспекты, перечисленные на этом слайде,
      в совокупности и являются тем стоп-фактором,
      который мешает более широкому применению традиционных DI-контейнеров.

